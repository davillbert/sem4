#include <iostream>
//#include <vector>
#include <memory>
using namespace std;

template<class T>
class BankCell
{

	//ячейка имеет владельцев - массив указателей, расшаренный указатель на какое-то число человек, 
	//ячейка закрывается, если пустует проверять вектор на is empty и если true то кикать, выводить, что пустая и удалять
	// у ячейкм поля - массив привязанных к ней челов
	// ячейка добавляет людей в массив, проверяет на пустотоу этот массив
	// умеет удалять человека из массива если он мертв(указатель на него нуллптр)

private:
	// создали массив указтелей на хозяев ячейки




public:
	BankCell(T* ptr = nullptr)
		:m_ptr(ptr)
	{
	}

	void setPerson(Person* p) { if (p == nullptr) delete m_ptr}
	~BankCell()
	{
		delete m_ptr;
	}

	// Конструктор копирования, который реализовывает семантику перемещения
	


};

class Person
{

	//человек умеет давать информация о своей ячейке
	//умеет давать информацию о себе, то есть передат указатель нуллптр если мертв, НЕнулл если нет
     //делаем указатель на объект, то есть на человека
shared_ptr<BankCell> BC = nullptr(new BankCell);
	//BankCell* BC; // закладываем ссылку на указатель на банковскуюю ячейку, у чела условно одна ячейка
public:
	Person() (BankCell* BC) : BC(BC) { cout << "Make a person\n"; } // присваиваем челу ячейку там расшаренный указатель
	
 // создаем ptr2 напрямую из item (вместо ptr1)

	int getHuman() { return *BC; } //получаем указатель на чела

	~Person()
	{
		delete &BC; //тут убиваем чела
		cout << "Destroy a person\n";
	}
};

-----------------
#include <iostream>
//#include <vector>
#include <memory>
using namespace std;

template<class T>
class BankCell
{

	//ячейка имеет владельцев - массив указателей, расшаренный указатель на какое-то число человек, 
	//ячейка закрывается, если пустует проверять вектор на is empty и если true то кикать, выводить, что пустая и удалять
	// у ячейкм поля - массив привязанных к ней челов
	// ячейка добавляет людей в массив, проверяет на пустотоу этот массив
	// умеет удалять человека из массива если он мертв(указатель на него нуллптр)

private:
	


	
	
public:
	BankCell(T* ptr = nullptr)
		:m_ptr(ptr)
	{
	}

	~BankCell()
	{
		delete m_ptr;
	}

	// Конструктор копирования, который реализовывает семантику перемещения
	BankCell(BankCell& a) // примечание: Ссылка не является константной
	{
		m_ptr = a.m_ptr; // перемещаем наш глупый указатель от источника к нашему локальному объекту
		a.m_ptr = nullptr; // подтверждаем, что источник больше не владеет указателем
	}

	// Оператор присваивания, который реализовывает семантику перемещения
	BankCell& operator=(BankCell& a) // примечание: Ссылка не является константной
	{
		if (&a == this)
			return *this;

		delete m_ptr; // подтверждаем, что удалили любой указатель, который наш локальный объект имел до этого
		m_ptr = a.m_ptr; // затем перемещаем наш глупый указатель из источника к нашему локальному объекту
		a.m_ptr = nullptr; // подтверждаем, что источник больше не владеет указателем
		return *this;
	}

	T& operator*() const { return *m_ptr; }
	T* operator->() const { return m_ptr; }
	bool isNull() const { return m_ptr == nullptr; }
};

class Person
{
private:
	//человек умеет давать информация о своей ячейке, она у него условно единственная
	//умеет давать информацию о себе, то есть передат указатель нуллптр если мертв, НЕнулл если нет
	unique_ptr<Person> human=nullptr(new Person); //делаем указатель на объект, то есть на человека
	//BankCell* BC; // закладываем ссылку на указатель на банковскуюю ячейку, у чела условно одна ячейка
public:
	Person() (Person* human) : human(human) { cout << "Make a person\n"; } // присваиваем челу чела

	int getHuman() { return *human; } //получаем указатель на чела

	~Person() 
	{
		delete human; //тут убиваем чела
		cout << "Destroy a person\n"; 
	}
};
